# Test-task-
Ответы на 3 вопроса.

Вопрос №1  На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 
Пример: 
def isEven(value):
      return value % 2 == 0

Ответ:

def even_number(number):
    if (number >= 0):
        return (number % 2 == 0)

number = int(input("Введите число:"))
if (even_number(number) == True):
    print("Число четное!")

else:
    print("Число нечетное!")

Тут несколько отметок оставлю:

1. Функция будет реагировать ни 0, так как 0 = Если число оканчивается на ноль, то это признак четности. Соответственно и сам 0 относится к четным. Ноль делится на два без остатка. Поэтому его относят к четным числам;

2. Не будет работать с отрицательными числами;

3. Второй алгоритм, реализован с помощью рекурсии - соответственно, издержки по памяти будет немного выше - O(1) (константная память)
Скорость выполнения: O(1) (константное время);

4. Когда пользователь вводит нецелое (дробное число или строку). В этом случае произойдет ошибка при попытке преобразования входных данных в целое число с помощью функции int().

+ Когда пользователь вводит специальные символы (напр, буквы, знаки препинания) или ничего не вводит вообще. В этом случае также может произойти ошибка при попытке преобразования входных данных в целое число с помощью функции int().


Вопрос №2  На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.
Оценивается:
 1 Полнота и качество реализации
 2 Оформление кода
 3 Наличие сравнения и пояснения по быстродействию

Ответ:
Вариант 1: Циклический буфер FIFO с использованием списка

class RingBuffer():
    def init(self, size):
        self.queue = [None] * size
        self.size = size
        self.head = 0  # идекс первого элемента в очереди
        self.tail = 0  # индекс последнего элемента в очереди
        self.count = 0  # текущее количество элементов в очереди

    def append(self, value):
        self.queue.append(value)
        if self.count == self.size:
            raise Exception("Очередь перолнена")

        self.queue[self.tail] = value
        self.tail = (self.tail + 1) % self.size
        self.count += 1

    def remove(self):
        if self.count == 0:
            raise Exception("Очередь пуста")

        value = self.queue[self.head]
        self.head = (self.head + 1) % self.size
        self.count -= 1
        return value

    def repr(self):
        return f"RingBuffer(size={self.size}, head={self.head}, tail={self.tail}, count={self.count})"

Плюсы:
- Реализован с помощью списка;
- О-натация: О(1) - за констанстное время (Мы храним индексы, но меняем);
- Тут мы переносим циклически указатель головы и хвоста, что позволяет избежать перезаписи элементов при добавлении новых элементов.

Минусы:
- Раздемер должен быть заранее задан. Если понадобится увеличить размер, то нужно будет создать отдельно вовый экзкпляр класса большего размера.

Для реализации первого варианта использовалась теория: "Теория кольцевого буфера
Ключевая особенность в работе кольцевого буфера — возможность добавлять и удалять элементы без перераспределения массива. Действительно, если предположить, что количество элементов в массиве всегда является константой (что для расчетов в скользящем окне так и есть), то добавление нового элемента сопровождается удалением старого. Таким образом, общее количество элементов не изменяется, но меняется их индексация при добавлении каждого нового элемента.   Последний элемент становится предпоследним, второй элемент занимает место первого, а первый безвозвратно уходит из очереди."

Вариант 2: Более сложнаяруктура -> Использование связного списка

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class CircularBuffer:
    def __init__(self, size):
        self.size = size
        self.head = None    # указатель на первый элемент в буфере
        self.tail = None    # указатель на последний в буфере
        self.count = 0      # текущее количество элементов в буфере

    def enqueue(self, value):
        if self.count == self.size:
            raise Exception("Буфер переполнен")

        node = Node(value)
        if self.count == 0:
            self.head = node
            self.tail = node
            self.next = self.head
        else:
            self.tail.next = node
            self.tail = node
            self.tail.next = self.head

        self.count += 1

    def dequeue(self):
        if self.count == 0:
            raise Exception("Буфер пуст")

        value = self.head.value
        if self.count > 1:
            self.head = self.head.next
            self.tail.next =.head
        else:
            self.head = None
            self.tail = None

        self.count -= 1
        return value

    def __repr__(self):
        return f"CircularBuffer(size={self.size}, head={self.head}, tail={self.tail}, count={self.count})"

Плюсы:
- Динамическое изменение размера;
- Для доспута к голове и хвосту используются указатели;

Минусы:
- Более сложнаяруктура. Требуется следить за указателями.
  

Вопрос №3  На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.
